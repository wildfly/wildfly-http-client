= Wildfly Service Invocation over HTTP Specification, Version 2
:Author:    Richard Achmatowicz
:Email:     <rachmato@redhat.com>
:Date:      2024
:Revision:  1.0
:toc:   left


== Overview

This document specifies the way in which EJB and other services may be invoked over HTTP. At present this includes:

* EJB
* JNDI
* Transactions

However, more may be added in future versions.

=== Design notes

This protocol is intended to conform to HTTP semantics as closely as possible, however it is not intended to be a RESTful protocol. The semantics of EJB invocation to not necessarily map well to REST, and JAX-RS already provides a standard way to map EJB invocation to RESTful web services.

TODO: do we hard code the 'river' marshalling strategy or do we require a header that specifies the strategy?

== Protocol

The protocol is based on HTTP, and is intended to be used over both HTTP/1.1 and HTTP/2. All services are mapped a location in the _HTTP Invoker Context Path_ which by default is +/wildfly-services+. This context path is configurable per connector, and can be disabled entirely. Each specific protocol will be mapped to a sub location inside the invoker context path. For example EJB will be mapped to +/wildfly-services/ejb/+.

All invocations share some common elements no matter the underlying service that are detailed here.

Note that when using multiple servers/clusters with different deployments behind the same load balancer it will be necessary to map each cluster to a different path. For instance if you have 5 servers serving application A and 7 servers serving application B each group of servers must have a different context path configured so that the load balancer knows where to send the requests.

Some services will use the +JSESSIONID+ cookie to set an affinity with a particular node. If this cookie is sent its path must be equal to the HTTP invoker context path.

=== Versioning

All requests are versioned, with the version specified in the +Content-Type+ header of the request as a parameter named +version+. If the server is not able to process the specified version it will send back a +406+ response with the accept parameter detailing supported versions. All servers and clients that implement a given protocol must support version 1. A client may query the supported versions by sending a +HEAD+ request.

=== Request and Response Type

The request and response type is specified through the content type header. All types should be of the form +application/x-wf-$\{type}; version=$version+. In this version of the specification, all message versions are version 2.

=== Compression

Compression is optionally supported by all protocols and message types, and is indicated by the +Content-Encoding+. Gzip should be supported by default. A client must send an +Accept-Encoding+ header to the server detailing the acceptable compression types if it supports compression.

Request compression is also supported, however as the client has no way to know if the server will be able to decompress it must be prepared to resend a non compressed response if the server cannot process it. If the server cannot process the compressed request it will respond with a +406+ status code and an +Accept-Encoding+ header that specifies the compression types it supports (this header may be empty). A client may query the supported compression types by sending a +HEAD+ request.

=== Standard HTTP compatibility

Note that for any request the client should also be prepared to accept a HTTP response that is not one of the expected messages. This includes +302+ redirects and HTTP basic auth via a +401+ response, as well as handing +404+ and other errors that may be generated by a load balancer that is not aware of the protocol.

=== Security

All protocols should share the same security and authentication mechanisms. In general this should involve the use of standard HTTP authentication mechanisms (BASIC, CLIENT_CERT etc).
TODO: Fill out this section

=== Clustering, mod_cluster and load balancer support

These protocols must support mod_cluster, and should be designed to work with existing load balancers. The +JSESSIONID+ cookie should be used to convey affinity, as this allows existing load balancers that support sticky sessions to work without any modification.

This protocol does not directly support clustering, clustering is achieved using standard HTTP load balancing based techniques.

== Summary of changes from the previous version (v1)

This section outlines the significant changes when moving from version 1 to version 2.

=== Interoperability protocol

The major requirement for version 2 was to handle the implications of the move from Java EE to Jakarta EE in Jakarta EE 9. Due to the renaming of packages from javax.* (in Java EE)
to jakarta.* (in Jakarta EE), it is now possible for four separate scenarios to coexist between client and server:

* a Java EE client with a Java EE server
* a Java EE client with a Jakarta EE server
* a Jakarta EE client with a Java EE server
* a Jakarta EE client with a Jakarta EE server

Both the client and the server must agree on how to marshal and unmarshal the classes exchanged, in a way that respects package name differences. A new _interoperability protocol_
was introduced to facilitate this agreement. The protocol involves the coordinated use two sets of marshalers:

* interoperability marshaller (marshals package names javax.* to jakarta.* )
* interoperability unmarshaller (unmarshals package names jakarta.* to javax.* )
* default marshaller (no special package name treatment)
* default unmarshaller (no special package name treatment)

The interoperability protocol is designed to be completed on the first request/response cycle of a connection between a client and server. Once protocol has completed,
it ensures that for all subsequent request/response cycles on that connection, the appropriate marshaller and unmarshaller is used on the client side and the appropriate
unmarshaller and marshaller is used on the server side.

The current implementation of the interoperability protocol uses a single additional header, x-wf-version, and makes use of the context path version to identify the marshalling choices determined
by the interoperability protocol:

* v1 => client uses interoperability marshaller and default Jakarta EE unmarshaller, server uses default Jakarta EE unmarshaller and interoperability marshaller
* v2 => client uses default Jakarta EE marshaller and default Jakarta EE unmarshaller, server uses default Jakarta EE unmarshaller and default Jakarta EE marshaller

In order to permit backward compatability, the first request/response cycle of a connection will always use the v1 protocol, but now with with the additional header
x-wf-version added. Subsequent requests will select and stay with either v1 or v2, depending on the combination of client and server.

The detailed implementation of the interoperability protocol is beyond the scope of this document.

== Common Messages

=== Request Messages

==== Session Affinity

Method:: ++GET++
Message Type:: None
URI:: +/common/v2/affinity+
Additional Required Headers:: None
Additional Optional Headers:: None
Request Body:: Empty
Notes::
This message generates a session id, that can be used to make sure requests end up at the same backend node.

=== Response Messages

==== Session Affinity Result

Message Type:: None
Additional Required Headers::
+Set-Cookie: JSESSIONID=\{sessionAffinityKey}+
Additional Optional Headers:: None
Response Body:: Empty
Response Codes::
 * +202+ Returned for a successful invocation

==== Exception

Message Type:: +application/x-wf-jbmar-exception+
Additional Required Headers:: None
Additional Optional Headers:: None
Response Body::
This response body contains a serialized representation of the exception, followed by a serialized representation of the attachments map
Response Codes::
 * +400+ General malformed request (missing headers etc)
 * +403+ Authorization failure
 * +404+ Returned if the resource could not be found
 * +408+ Invocation cancelled
 * +500+ Method processing threw an exception

== EJB Protocol

The EJB protocol is mapped to the +/ejb+ context inside the HTTP invoker context path. When specifying the URI for a request all fields are required, if they are null or empty they should be replaced with a ‘-’ character.

This protocol has been designed to work with the existing EJB client API.

Cancellation support is provided through the use of a client side invocation id and a session cookie. The session cookie makes sure a cancellation goes to the correct server and ensures there are no conflicts, while the invocation id is used to identity the invocation to cancel.

=== Request Messages

==== EJB Invocation

Method:: +POST+
Message Type:: +application/x-wf-jbmar-invocation+
URI:: +/ejb/v2/invoke/\{applicationName}/\{moduleName}/\{distinctName}/\{beanName}/\{sfsbSessionId}/\{viewClass}/\{methodName}/\{paramType1}/\{paramType1}/...+
Additional Required Headers::
+Accept:application/x-wf-ejb-jbmar-response;version=1,application/x-wf-jbmar-exception;version=1+
Additional Optional Headers::
+Cookie: JSESSIONID=\{sessionAffinityKey}+, +
+X-wf-invocation-id: {invocationId}+
Request Body::
The request body is serialized with JBoss Marshalling. The first item is a serialized transaction, which consists of a byte to indicate if a transaction is present (0 for not present, 1 for remote, 2 for locally outflowed).
If the transaction byte is 1 or 2 then it will be followed by an integer and two byte arrays, which represent the format, global and branch parts of an Xid.
The method body consists of n parameter values, serialized using JBoss Marshalling, followed by a serialized attachments map of the form +Map<String, Object>+.

Notes::
This message sends a request to the server. If the request completes successfully (or is submitted successfully in the case of a void returning async EJB methods) the server will respond with an +x-wf-ejb-jbmar-response response+. If an error occurred the server will respond with an +x-wf-jbmar-exception+ response.

If the invocation id is specified the session id must also be specified. The client can use an affinity message to get a session id if it does not already have one. The invocation id should only be set for requests that require cancellation support.

The sfsbSessionId parameter is a base64 encoded representation of the SFSB EJB session id, if the invocation is not targeting a stateful bean then it should be a +-+.

==== EJB Session Open

Method:: +POST+
Message Type:: +application/x-wf-jbmar-sess-open+
URI:: +/ejb/v2/open/\{applicationName}/\{moduleName}/\{distinctName}/\{beanName}+
Additional Required Headers::
+Accept: application/x-wf-jbmar-exception;version=1+
Additional Optional Headers::
+Cookie: JSESSIONID=\{sessionAffinityKey}+
Request Body::
The request body contains a serialized transaction (see the invocation message for details).

==== EJB Cancel

Method:: ++DELETE++
Message Type:: None
URI:: +/ejb/v2/cancel/\{applicationName}/\{moduleName}/\{distinctName}/{beanName}/\{invocation-id}\{interupt-if-running}+
Additional Required Headers::
+Cookie: JSESSIONID=\{sessionAffinityKey}+
Additional Optional Headers:: None
Request Body:: Empty
Notes::
This message cancels an async request.

==== EJB Discovery

Method:: ++GET++
Message Type:: None
URI:: +/ejb/v2/discover+
Additional Required Headers:: None
Additional Optional Headers:: None
Request Body:: Empty
Notes::
This message initiates a discovery request to a cluster of nodes behind a load balancer.


=== Response Messages

==== EJB Response

Message Type:: +application/x-wf-ejb-jbmar-response+
Additional Required Headers:: None
Additional Optional Headers::
+Set-Cookie: JSESSIONID=\{sessionAffinityKey}+
Response Body::
For non-void methods the response body contains the serialized response object, followed by the serialized attachments map. For void methods the serialized object will be the serialized representation of +null+.
Response Codes::
 * +200+ Returned for a successful invocation
 * +202+ Returned for a successful invocation of an asynchronous method. This will be returned immediately, the request may not have finished processing yet.

==== EJB New Session

Message Type:: None
Additional Required Headers::
+x-wf-ejb-session-id: \{newSessionId}+
Additional Optional Headers::
+Set-Cookie: JSESSIONID=\{sessionAffinityKey}+
Response Body:: Empty
Response Codes::
 * +204+ Returned for a successful invocation
Notes::
In most cases it is expected that session affinity will be used to make sure that invocations on the EJB target the correct server.

==== EJB Cancelled

Message Type:: None
Additional Required Headers:: None
Additional Optional Headers:: None
Response Body:: Empty
Response Codes:: 
 * +202+ Returned for a successful invocation
 * +404+ Returned if the invocation was not found (i.e. it has already completed)

=== EJB Discovery Response

Message Type:: +application/x-wf-ejb-jbmar-discovery-response+
Additional Required Headers:: None
Additional Optional Headers:: None
Response Body::
The response body contains the serialized list of available modules, the size of the list followed by the list of module identifiers. Note that if no modules
are deployed, the size may be zero and the list empty.
Response Codes::
* +200+ Returned for a successful invocation
Notes::
The discovery mechanism assumes that the deployments in the cluster are homogeneous; in other words, the same modules are deployed on every node in the cluster.

== JNDI Protocol

The JNDI protocol provides similar functionality to the existing remote JNDI implementation, but over HTTP. All JNDI URL’s are prefixed with +/jndi+.

=== Request Messages

==== JNDI Lookup

Method:: +POST+
Message Type:: None
URI:: +/naming/v2/lookup/\{jndiName}+
Additional Required Headers::
+Accept: application/x-wf-jndi-jbmar-value;version=1,application/x-wf-jbmar-exception;version=1+
Additional Optional Headers::
+Cookie: JSESSIONID=\{sessionAffinityKey}+
Request Body:: Empty
Notes::
This message sends a JNDI Lookup request to the server. If the request completes successfully the server will respond with an +x-wf-jndi-jbmar-value+ response. If an error occurred the server will respond with an +x-wf-jbmar-exception+ response.
Note that because JNDI lookups are not idempotent this method is a +POST+, rather than a +GET+ (namely lookups can cause the creation of SFSB’s).

==== JNDI Lookup Link

Method:: +GET+
Message Type:: None
URI:: +/naming/v2/lookuplink/\{jndiName}+
Additional Required Headers::
+Accept: application/x-wf-jndi-jbmar-value;version=1,application/x-wf-jbmar-exception;version=1+
Additional Optional Headers:: Cookie: JSESSIONID=\{sessionAffinityKey}
Request Body:: Empty
Notes::
This message sends a JNDI Lookup Link request to the server. If the request completes successfully the server will respond with an +x-wf-jndi-jbmar-value response+. If an error occurred the server will respond with an +x-wf-jbmar-exception+ response.

==== JNDI Bind

Method:: +PUT+
Message Type:: +application/x-wf-jndi-jbmar-value+
URI:: +/naming/v2/bind/\{jndiName}+
Additional Required Headers::
+Accept: application/x-wf-jndi-jbmar-result;version=1,application/x-wf-jbmar-exception;version=1+
Additional Optional Headers:: 
+Cookie: JSESSIONID=\{sessionAffinityKey}+
Request Body::
Serialized representation of the object to bind

==== JNDI Rebind

Method:: +PATCH+
Message Type:: +application/x-wf-jndi-jbmar-value+
URI:: +/naming/v2/rebind/\{jndiName}+
Additional Required Headers::
+Accept: application/x-wf-jndi-jbmar-result;version=1,application/x-wf-jbmar-exception;version=1+
Additional Optional Headers:: 
+Cookie: JSESSIONID=\{sessionAffinityKey}+
Request Body::
Serialized representation of the object to rebind

==== JNDI Unbind

Method:: ++DELETE++
Message Type:: None
URI:: +/naming/v2/unbind/\{jndiName}+
Additional Required Headers::
+Accept: application/x-wf-jndi-jbmar-result;version=1,application/x-wf-jbmar-exception;version=1+
Additional Optional Headers::
+Cookie: JSESSIONID=\{sessionAffinityKey}+
Request Body:: Empty

==== JNDI Destroy Subcontext

Method:: +DELETE+
Message Type:: None
URI:: +/naming/v2/dest-subctx\{jndiName}+
Additional Required Headers::
+Accept: application/x-wf-jndi-jbmar-result;version=1,application/x-wf-jbmar-exception;version=1+
Additional Optional Headers::
+Cookie: JSESSIONID=\{sessionAffinityKey}+
Request Body:: Empty

==== JNDI List

Method:: +GET+
Message Type:: None
URI:: +/naming/v2/list/\{jndiName}+
Additional Required Headers::
+Accept: application/x-wf-jndi-jbmar-value;version=1,application/x-wf-jbmar-exception;version=1+
Additional Optional Headers::
+Cookie: JSESSIONID=\{sessionAffinityKey}+
Request Body:: Empty
Notes::
The response messages are the same as for a normal lookup, but contains a serialized +NamingEnumeration+.

==== JNDI List Bindings

Method:: +GET+
Message Type:: None
URI:: +/naming/v2/list-bindings/\{jndiName}+
Additional Required Headers::
+Accept: application/x-wf-jndi-jbmar-value;version=1,application/x-wf-jbmar-exception;version=1+
Additional Optional Headers::
+Cookie: JSESSIONID=\{sessionAffinityKey}+
Request Body:: Empty
Notes::
The response messages are the same as for a normal lookup, but contains a serialized NamingEnumeration

==== JNDI Rename

Method:: +PATCH+
Message Type:: None
URI:: +/naming/v2/rename/\{jndiName}&new=\{newName}+
Additional Required Headers::
+Accept: application/x-wf-jbmar-exception;version=1+
Additional Optional Headers::
+Cookie: JSESSIONID=\{sessionAffinityKey}+
Request Body:: Empty

==== JNDI Create Subcontext

Method:: +PUT+
Message Type:: None
URI:: +/naming/v2/create-subcontext/\{jndiName}+
Additional Required Headers::
+Accept: application/x-wf-jbmar-exception;version=1+
Additional Optional Headers::
+Cookie: JSESSIONID=\{sessionAffinityKey}+
Request Body:: Empty

=== JNDI Response Messages

==== JNDI Value

Message Type:: +application/x-wf-jndi-jbmar-value+
Additional Required Headers:: None
Additional Optional Headers::
+Set-Cookie: JSESSIONID=\{sessionAffinityKey}+
Response Body::
The serialized lookup result
Response Codes::
 * +200+ Returned for a successful invocation


==== JNDI Context

Message Type:: None
Additional Required Headers:: None
Additional Optional Headers:: None
Response Body:: Empty
Response Codes::
 * +204+ No Content
Notes::
This response is used to indicate that the result of the lookup was a Context object.

==== JNDI Result

Message Type:: None
Additional Required Headers:: None
Additional Optional Headers:: None
Response Body:: Empty
Response Codes::
 * +200+ Success
Notes::
This response is only used to indicate success for void returning methods.

== Transaction Support

=== Request Messages

==== Transaction Begin

Method:: +POST+
Message Type:: None
URI:: +/txn/v2/ut/begin+
Additional Required Headers::
+Accept: application/x-wf-jbmar-exception;version=1,application/x-wf-jbmar-new-txn;version=1+
x-wf-txn-timeout: {timeout}
Additional Optional Headers::
+Cookie: JSESSIONID=\{sessionAffinityKey}+
Request Body:: Empty

==== User Transaction Commit

Method:: +POST+
Message Type:: +application/x-wf-jbmar-xid;version=1+
URI:: +/txn/v2/ut/commit+
Additional Required Headers::
+Accept: application/x-wf-jbmar-exception;version=1+, +
+Cookie: JSESSIONID=\{sessionAffinityKey}+
Additional Optional Headers:: None
Request Body::
JBoss marshalling representation of formatId, global ID and branch ID (the components of an XID).


==== Transaction Rollback

Method:: +POST+
Message Type:: +application/x-wf-jbmar-xid;version=1+
URI:: +/txn/v2/\{type}/rollback+
Additional Required Headers::
+Accept: application/x-wf-jbmar-exception;version=1+, +
+Cookie: JSESSIONID=\{sessionAffinityKey}+
Additional Optional Headers:: None
Request Body::
JBoss marshalling representation of formatId, global ID and branch ID (the components of an XID).

==== Transaction before completion

Method:: +POST+
Message Type:: +application/x-wf-jbmar-xid;version=1+
URI:: +/txn/v2/xa/bc+
Additional Required Headers::
+Accept: application/x-wf-jbmar-exception;version=1+, +
+Cookie: JSESSIONID=\{sessionAffinityKey}+
Additional Optional Headers:: None
Request Body::
JBoss marshalling representation of formatId, global ID and branch ID (the components of an XID).

==== Distributed Transaction Prepare

Method:: +POST+
Message Type:: +application/x-wf-jbmar-xid;version=1+
URI:: +/txn/v2/xa/prep+
Additional Required Headers::
+Accept: application/x-wf-jbmar-exception;version=1+, +
+Cookie: JSESSIONID=\{sessionAffinityKey}+
Additional Optional Headers:: None
Request Body::
JBoss marshalling representation of formatId, global ID and branch ID (the components of an XID).
Notes::
The response to this message can contain the x-wf-txn-read-only header, which is used to indicate the
read only status of the result. If it is missing it is assumed to not be read only.

==== Distributed Transaction Commit

Method:: +POST+
Message Type:: +application/x-wf-jbmar-xid;version=1+
URI:: +/txn/v2/xa/commit(?opc=true)?+
Additional Required Headers::
+Accept: application/x-wf-jbmar-exception;version=1+, +
+Cookie: JSESSIONID=\{sessionAffinityKey}+
Additional Optional Headers:: None
Request Body:: Empty
Notes::
JBoss marshalling representation of formatId, global ID and branch ID (the components of an XID).
If the opc request parameter is present then a one phase commit is done.

==== Distributed Transaction Forget

Method:: +POST+
Message Type:: +application/x-wf-jbmar-xid;version=1+
URI:: +/txn/v2/xa/forget+
Additional Required Headers::
+Accept: application/x-wf-jbmar-exception;version=1+
Additional Optional Headers::
+Cookie: JSESSIONID=\{sessionAffinityKey}+
Request Body::
JBoss marshalling representation of formatId, global ID and branch ID (the components of an XID).

==== Distributed Transaction Recovery

Method:: +GET+
Message Type:: None
URI:: +/txn/v2/xa/recover+
Additional Required Headers::
+Accept: text/x-wf-txn-jbmar-xid-list;version=1,application/x-wf-jbmar-exception;version=1+, +
x-wf-txn-parent-name: The parent node name, +
x-wf-txn-recovery-flags: The recovery flags as a base 10 integer
Additional Optional Headers::
+Cookie: JSESSIONID=\{sessionAffinityKey}+
Request Body:: Empty

=== Transaction Responses


==== Begin Transaction

Message Type:: +application/x-wf-jbmar-new-txn;version=1+
Additional Required Headers::
+x-wf-txn-jbmar-id: \{transactionId}+
Additional Optional Headers::
+Set-Cookie: JSESSIONID=\{sessionAffinityKey}+
Response Body::
Jboss marshalling representation of formatId, global ID and branch ID (the components of an XID).

Response Codes::
 * +200+ Returned for a successful invocation

==== New Transaction

Message Type:: None
Additional Required Headers::
+x-wf-txn-jbmar-id: \{transactionId}+
Additional Optional Headers::
+Set-Cookie: JSESSIONID=\{sessionAffinityKey}+
Response Body:: Empty
Response Codes::
 * +202+ Returned for a successful invocation

==== Transaction Result

Message Type:: None
Additional Required Headers:: None
Additional Optional Headers::
+x-wf-txn-jbmar-xa-read-only:true+ :: If this is present then the XA result was read only (only relevant for the prepare operation)
Response Body:: Empty
Response Codes::
 * +204+ Success
Notes::
This response is used to indicate operation success


==== Transaction XIDS

Message Type:: +text/x-wf-txn-jbmar-xid-list+
Additional Required Headers:: None
Additional Optional Headers::
+Set-Cookie: JSESSIONID=\{sessionAffinityKey}+
Response Body::
Newline separated list of prepared but not submitted transactions
Response Codes::
 * +200+ Returned for a successful invocation

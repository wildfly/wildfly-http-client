= Wildfly Service Invocation over HTTP Specification, Version 3
:Author:    Richard Achmatowicz
:Email:     <rachmato@redhat.com>
:Date:      2024
:Revision:  1.0
:toc:   left


== Overview

This document specifies the way in which EJB and other services may be invoked over HTTP. At present this includes:

* EJB
* JNDI
* Transactions

However, more may be added in future versions.

=== Design notes

This protocol is intended to conform to HTTP semantics as closely as possible, however it is not intended to be a RESTful
protocol. The semantics of EJB invocation do not necessarily map well to REST, and JAX-RS already provides a standard way
to map EJB invocation to RESTful web services.

== Protocol

The protocol is based on HTTP, and is intended to be used over both HTTP/1.1 and HTTP/2. All services are mapped a location
in the _HTTP Invoker Context Path_ which by default is +/wildfly-services+. This context path is configurable per connector,
and can be disabled entirely. Each specific protocol will be mapped to a sub location inside the invoker context path.
For example EJB will be mapped to +/wildfly-services/ejb/+.

All invocations share some common elements no matter the underlying services that are detailed here.

Note that when using multiple servers/clusters with different deployments behind the same load balancer it will be necessary
to map each cluster to a different path. For instance if you have 5 servers serving application A and 7 servers serving application
B each group of servers must have a different context path configured so that the load balancer knows where to send the requests.

Some services will use the +JSESSIONID+ cookie to set an affinity with a particular node. If this cookie is sent its path
must be equal to the invoker context path.

=== Versioning

All requests are versioned, with the version specified in the +Content-Type+ header of the request as a parameter named +version+.
If the server is not able to process the specified version it will send back a +406+ response with the accept parameter detailing
supported versions. All servers and clients that implement a given protocol must support version 1. A client may query the
supported versions by sending a +HEAD+ request.

=== Request and Response Type

The request and response type is specified through the content type header. All types should be of the form +application/x-wf-$\{type}; version=$version+.
In this version of the specification, all message versions are version 3.

=== Compression

Compression is optionally supported by all protocols and message types, and is indicated by the +Content-Encoding+. Gzip should
be supported by default. A client must send an +Accept-Encoding+ header to the server detailing the acceptable compression
types, if it supports compression.

Request compression is also supported, however as the client has no way to know if the server will be able to decompress
it must be prepared to resend a non compressed response if the server cannot process it. If the server cannot process the
compressed request it will respond with a +406+ status code and an +Accept-Encoding+ header that specifies the compression
types it supports (this header may be empty). A client may query the supported compression types by sending a +HEAD+ request.

=== Standard HTTP compatibility

Note that for any request the client should also be prepared to accept a HTTP response that is not one of the expected messages.
This includes +302+ redirects and HTTP basic auth via a +401+ response, as well as handing +404+ and other errors that may
be generated by a load balancer that is not aware of the protocol.

=== Security

All protocols should share the same security and authentication mechanisms. In general this should involve the use of standard
HTTP authentication mechanisms (BASIC, CLIENT_CERT etc).

TODO: Fill out this section

=== Clustering, mod_cluster and load balancer support

These protocols must support mod_cluster, and should be designed to work with existing load balancers. The +JSESSIONID+ cookie
should be used to convey affinity, as this allows existing load balancers that support sticky sessions to work without any modification.

This protocol does not directly support clustering, clustering is achieved using standard HTTP load balancing based techniques.

== Summary of changes from the previous version (v2)

This section outlines the significant changes when moving from version 2 to version 3.

=== Context path compatability with mod_cluster

One of the goals of the wildfly-http-client is to be able to interact with a mod_cluster-based load balancer and take full
advantage of its features.

mod_cluster is a load balancer which provides a number of advantages over conventional load balancers. One such advantage is
the ability for the backend servers to communicate with the mod_cluster load balancer to convey information about the state
of the backend server: which applications are deployed, what the current load is, and so on. In particular, when an application
is deployed, the backend server registers a context path prefix with the mod_cluster front end, allowing the load balancer
to know exactly which of the backend servers are able to handle the request.
mod_cluster uses the HTTP request context path prefix to determine which application the request is directed to
and route the request to a backend server which is known to have that application deployed.

In the case of the wildfly-http-client, we wish to use the same approach to direct ejb, jndi and transaction operations
to backend servers in the most efficient way possible. To facilitate this, where appropriate, the context paths for the
wildfly-http-client have been restructured to be take advantage of this feature of mod_cluster. For example, requests involving
the EJB protocol should only be directed to backend servers where the J2EE module containing the EJB being invoked upon
is known to be deployed.

=== Versioning metadata moved to the HTTP Content-Type / Accept MIME type

In previous versions, the versioning information describing the HTTP invoker handlers to use for servicing a request was
embedded in the context path for each operation (e.g. /wildfly-services/ejb/v2/invoke...). In this version, this versioning
information has been moved into the standard HTTP headers: specifically into the MIME types used in requests and responses.
This change was in part a consequence of reorganizing the context paths for the operations to be mod_cluster compatible,
as well as allowing more flexibility in the way context paths are processed.

=== Encoding the marshalling strategy in the HTTP Content-Type / Accept MIME type

In previous versions, the MIME types used for requests and responses included the string -jbmar-, which referred to the
marshalling and unmarshalling strategy used, namely JBoss Marshalling. In version 3, this usage is extended to allow the
introduction of new marshalling strategies. This would allow, for example, use of the Protobuf marshalling scheme via
the string -protobuf-.

== Common Messages

=== Request Messages

==== Session Affinity

Method:: ++GET++
Message Type:: None
URI:: +/common/affinity+
Additional Required Headers::
Request Body:: Empty
Notes::
This message generates a session id, that can be used to make sure requests end up at the same backend node.

=== Response Messages

==== Session Affinity Result

Message Type:: None
Additional Required Headers::
+Set-Cookie: JSESSIONID=\{sessionAffinityKey}+
Additional Optional Headers:: None
Response Body:: Empty
Response Codes::
 * +202+ Returned for a successful invocation

==== Exception

Message Type:: +application/x-wf-jbmar-exception+
Response Body::
This response body contains a serialized representation of the exception, followed by a serialized representation of the attachments map
Response Codes::
 * +400+ General malformed request (missing headers etc)
 * +403+ Authorization failure
 * +404+ Returned if the resource could not be found
 * +408+ Invocation cancelled
 * +500+ Method processing threw an exception

== EJB Protocol

The EJB protocol is mapped to the +/ejb+ context inside the HTTP invoker context path. When specifying the URI for a request
all fields are required, if they are null or empty they should be replaced with a ‘-’ character.

This protocol has been designed to work with the existing EJB client API.

Cancellation support is provided through the use of a client side invocation id and a session cookie. The session cookie makes
sure a cancellation goes to the correct server and ensures there are no conflicts, while the invocation id is used to identity
the invocation to cancel.

=== Request Messages

==== EJB Invocation
Method:: +POST+
Message Type:: +application/x-wf-jbmar-invocation;version=3+
URI:: +/ejb/\{applicationName}/\{moduleName}/\{distinctName}/invoke/\{beanName}/\{sfsbSessionId}/\{viewClass}/\{methodName}/\{paramType1}/\{paramType1}/...+
Additional Required Headers::
+Accept: application/x-wf-ejb-jbmar-response;version=3,application/x-wf-ejb-jbmar-response;version=1,application/x-wf-jbmar-exception;version=1+
Additional Optional Headers::
+Cookie: JSESSIONID=\{sessionAffinityKey}+
X-wf-invocation-id: {invocationId}
Request Body::
The request body is serialized with JBoss Marshalling. The first item is a serialized transaction, which consists of a byte
to indicate if a transaction is present (0 for not present, 1 for remote, 2 for locally outflowed). If the transaction byte
is 1 or 2 then it will be followed by an integer and two byte arrays, which represent the format, global and branch parts of an Xid.
The method body consists of n parameter values, serialized using JBoss Marshalling, followed by a serialized attachments map
of the form +Map<String, Object>+.
Notes::
This message sends a request to the server. If the request completes successfully (or is submitted successfully in the case
of a void returning async EJB methods) the server will respond with an +x-wf-ejb-jbmar-response response+. If an error occurred
the server will respond with an +x-wf-jbmar-exception+ response.

If the invocation id is specified the session id must also be specified. The client can use an affinity message to get a
session id if it does not already have one. The invocation id should only be set for requests that require cancellation support.

The sfsbSessionId parameter is a base64 encoded representation of the SFSB EJB session id, if the invocation is not targeting
a stateful bean then it should be a +-+.

==== EJB Session Open

Method:: +POST+
Message Type:: +application/x-wf-jbmar-sess-open;version=3+
URI:: +/ejb/\{applicationName}/\{moduleName}/\{distinctName}/open/\{beanName}+
Additional Required Headers::
+Accept: application/x-wf-jbmar-exception;version=1+
Additional Optional Headers::
+Cookie: JSESSIONID=\{sessionAffinityKey}+
Request Body::
The request body contains a serialized transaction (see the invocation message for details).

==== EJB Cancel

Method:: ++DELETE++
Message Type:: +application/x-wf-cancel;version=3+
URI:: +/ejb/\{applicationName}/\{moduleName}/\{distinctName}/cancel/{beanName}/\{invocation-id}\{interupt-if-running}+
Additional Required Headers::
+Cookie: JSESSIONID=\{sessionAffinityKey}+
Request Body:: Empty
Notes::
This message cancels an async request.

==== EJB Discovery

Method:: ++GET++
Message Type:: +application/x-wf-discover;version=3+
URI:: +/ejb/discover+
Additional Required Headers:: None
Request Body:: Empty
Notes::
This message initiates a discovery request to a cluster of nodes behind a load balancer.


=== Response Messages

==== EJB Response

Message Type:: +application/x-wf-ejb-jbmar-response+
Additional Required Headers:: None
Additional Optional Headers::
+Set-Cookie: JSESSIONID=\{sessionAffinityKey}+
Response Body::
For non void methods the response body contains the serialized response object, followed by the serialized attachments map.
For void methods the serialized object will be the serialized representation of +null+.
Response Codes::
 * +200+ Returned for a successful invocation
 * +202+ Returned for a successful invocation of an asynchronous method. This will be returned immediately, the request may
not have finished processing yet.

==== EJB New Session

Message Type:: None
Additional Required Headers::
+x-wf-ejb-session-id: \{newSessionId}+
Additional Optional Headers::
+Set-Cookie: JSESSIONID=\{sessionAffinityKey}+
Response Body:: Empty
Response Codes::
 * +204+ Returned for a successful invocation
Notes::
In most cases it is expected that session affinity will be used to make sure that invocations on the EJB target the correct server.

==== EJB Cancelled

Message Type:: None
Additional Required Headers:: None
Additional Optional Headers:: None
Response Body:: Empty
Response Codes:: 
 * +202+ Returned for a successful invocation
 * +404+ Returned if the invocation was not found (i.e. it has already completed)

=== EJB Discovery Response

Message Type:: +application/x-wf-ejb-jbmar-discovery-response+
Additional Required Headers:: None
Additional Optional Headers:: None
Response Body::
The response body contains the serialized list of available modules, the size of the list followed by the list of module
identifiers. Note that if no modules are deployed, the size may be zero and the list empty.
Response Codes::
* +200+ Returned for a successful invocation
Notes::
The discovery mechanism assumes that the deployments in the cluster are homogeneous; in other words, the same modules are
deployed on every node in the cluster.

== JNDI Protocol

The JNDI protocol provides similar functionality to the existing remote JNDI implementation, but over HTTP. All JNDI URL’s
are prefixed with +/jndi+.

=== Request Messages

==== JNDI Lookup

Method:: +POST+
Message Type:: None
URI:: +/naming/lookup/\{jndiName}+
Additional Required Headers::
+Accept: application/x-wf-jndi-jbmar-value;version=1,application/x-wf-jbmar-exception;version=1+
Additional Optional Headers::
+Cookie: JSESSIONID=\{sessionAffinityKey}+
Request Body:: Empty
Notes::
This message sends a JNDI Lookup request to the server. If the request completes successfully the server will respond with
an +x-wf-jndi-jbmar-value+ response. If an error occurred the server will respond with an +x-wf-jbmar-exception+ response.

Note that because JNDI lookups are not idempotent this method is a +POST+, rather than a +GET+ (namely lookups can cause
the creation of SFSB’s).

==== JNDI Lookup Link

Method:: +GET+
Message Type:: None
URI:: +/naming/lookuplink/\{jndiName}+
Additional Required Headers::
+Accept: application/x-wf-jndi-jbmar-value;version=1,application/x-wf-jbmar-exception;version=1+
Additional Optional Headers::
+Cookie: JSESSIONID=\{sessionAffinityKey}+
Request Body:: Empty
Notes::
This message sends a JNDI Lookup Link request to the server.

If the request completes successfully the server will respond with an +x-wf-jndi-jbmar-value response+.

If an error occurred the server will respond with an +x-wf-jbmar-exception+ response.

==== JNDI Bind

Method:: PUT
Message Type:: +application/x-wf-jndi-jbmar-value+
URI:: +/naming/bind/\{jndiName}+
Additional Required Headers:: 
+Accept: application/x-wf-jndi-jbmar-result;version=1,application/x-wf-jbmar-exception;version=1+
Additional Optional Headers:: 
+Cookie: JSESSIONID=\{sessionAffinityKey}+
Request Body::
Serialized representation of the object to bind

==== JNDI Rebind

Method:: +PATCH+
Message Type:: +application/x-wf-jndi-jbmar-value+
URI:: +/naming/rebind/\{jndiName}+
Additional Required Headers:: 
+Accept: application/x-wf-jndi-jbmar-result;version=1,application/x-wf-jbmar-exception;version=1+
Additional Optional Headers:: 
+Cookie: JSESSIONID=\{sessionAffinityKey}+
Request Body::
Serialized representation of the object to rebind

==== JNDI Unbind

Method:: ++DELETE++
Message Type:: None
URI:: +/naming/unbind/\{jndiName}+
Additional Required Headers:: 
+Accept: application/x-wf-jndi-jbmar-result;version=1,application/x-wf-jbmar-exception;version=1+
Additional Optional Headers::
+Cookie: JSESSIONID=\{sessionAffinityKey}+
Request Body:: Empty

==== JNDI Destroy Subcontext

Method:: +DELETE+
Message Type:: None
URI:: +/naming/dest-subctx\{jndiName}+
Additional Required Headers::
+Accept: application/x-wf-jndi-jbmar-result;version=1,application/x-wf-jbmar-exception;version=1+
Additional Optional Headers::
+Cookie: JSESSIONID=\{sessionAffinityKey}+
Request Body:: Empty

==== JNDI List

Method:: +GET+
Message Type:: None
URI:: +/naming/list/\{jndiName}+
Additional Required Headers::
+Accept: application/x-wf-jndi-jbmar-value;version=1,application/x-wf-jbmar-exception;version=1+
Additional Optional Headers::
+Cookie: JSESSIONID=\{sessionAffinityKey}+
Request Body:: Empty
Notes::
The response messages are the same as for a normal lookup, but contains a serialized +NamingEnumeration+.

==== JNDI List Bindings

Method:: +GET+
Message Type:: None
URI:: +/naming/list-bindings/\{jndiName}+
Additional Required Headers::
+Accept: application/x-wf-jndi-jbmar-value;version=1,application/x-wf-jbmar-exception;version=1+
Additional Optional Headers::
+Cookie: JSESSIONID=\{sessionAffinityKey}+
Request Body:: Empty
Notes::
The response messages are the same as for a normal lookup, but contains a serialized NamingEnumeration

==== JNDI Rename

Method:: +PATCH+
Message Type:: None
URI:: +/naming/rename/\{jndiName}&new=\{newName}+
Additional Required Headers::
+Accept: application/x-wf-jbmar-exception;version=1+
Additional Optional Headers::
+Cookie: JSESSIONID=\{sessionAffinityKey}+
Request Body:: Empty

==== JNDI Create Subcontext

Method:: +PUT+
Message Type:: None
URI:: +/naming/create-subcontext/\{jndiName}+
Additional Required Headers::
+Accept: application/x-wf-jbmar-exception;version=1+
Additional Optional Headers::
+Cookie: JSESSIONID=\{sessionAffinityKey}+
Request Body:: Empty

=== JNDI Response Messages

==== JNDI Value

Message Type:: +application/x-wf-jndi-jbmar-value+
Additional Required Headers:: None
Additional Optional Headers::
+Set-Cookie: JSESSIONID=\{sessionAffinityKey}+
Response Body::
The serialized lookup result
Response Codes::
 * +200+ Returned for a successful invocation


==== JNDI Context

Message Type:: None
Additional Required Headers:: None
Additional Optional Headers:: None
Response Body:: Empty
Response Codes::
 * +204+ No Content
Notes::
This response is used to indicate that the result of the lookup was a Context object.

==== JNDI Result

Message Type:: None
Additional Required Headers:: None
Additional Optional Headers:: None
Response Body:: Empty
Response Codes::
 * +200+ Success
Notes::
This response is only used to indicate success for void returning methods.

== Transaction Support

=== Request Messages

==== Transaction Begin

Method:: +POST+
Message Type:: None
URI:: +/txn/ut/begin+
Additional Required Headers::
+Accept: application/x-wf-jbmar-exception;version=1,application/x-wf-jbmar-new-txn;version=1+
x-wf-txn-timeout: {timeout}
Additional Optional Headers::
+Cookie: JSESSIONID=\{sessionAffinityKey}+
Request Body:: Empty

==== User Transaction Commit

Method:: +POST+
Message Type:: +application/x-wf-jbmar-xid;version=1+
URI:: +/txn/ut/commit+
Additional Required Headers::
+Accept: application/x-wf-jbmar-exception;version=1+
+Cookie: JSESSIONID=\{sessionAffinityKey}+
Additional Optional Headers:: Nnne
Request Body::
JBoss marshalling representation of formatId, global ID and branch ID (the components of an XID).


==== Transaction Rollback

Method:: +POST+
Message Type:: +application/x-wf-jbmar-xid;version=1+
URI:: +/txn/\{type}/rollback+
Additional Required Headers::
+Accept: application/x-wf-jbmar-exception;version=1+
+Cookie: JSESSIONID=\{sessionAffinityKey}+
Additional Optional Headers:: Nnne
Request Body::
JBoss marshalling representation of formatId, global ID and branch ID (the components of an XID).

==== Transaction before completion

Method:: +POST+
Message Type:: +application/x-wf-jbmar-xid;version=1+
URI:: +/txn/xa/bc+
Additional Required Headers::
+Accept: application/x-wf-jbmar-exception;version=1+
+Cookie: JSESSIONID=\{sessionAffinityKey}+
Additional Optional Headers:: Nnne
Request Body::
JBoss marshalling representation of formatId, global ID and branch ID (the components of an XID).

==== Distributed Transaction Prepare

Method:: +POST+
Message Type:: +application/x-wf-jbmar-xid;version=1+
URI:: +/txn/xa/prep+
Additional Required Headers::
+Accept: application/x-wf-jbmar-exception;version=1+
+Cookie: JSESSIONID=\{sessionAffinityKey}+
Additional Optional Headers:: Nnne
Request Body::
JBoss marshalling representation of formatId, global ID and branch ID (the components of an XID).
Notes::
The response to this message can contain the x-wf-txn-read-only header, which is used to indicate the
read only status of the result. If it is missing it is assumed to not be read only.

==== Distributed Transaction Commit

Method:: +POST+
Message Type:: +application/x-wf-jbmar-xid;version=1+
URI:: +/txn/xa/commit(?opc=true)?+
Additional Required Headers::
+Accept: application/x-wf-jbmar-exception;version=1+
+Cookie: JSESSIONID=\{sessionAffinityKey}+
Additional Optional Headers:: Nnne
Request Body:: Empty
Notes::
JBoss marshalling representation of formatId, global ID and branch ID (the components of an XID).
If the opc request parameter is present then a one phase commit is done.

==== Distributed Transaction Forget

Method:: +POST+
Message Type:: +application/x-wf-jbmar-xid;version=1+
URI:: +/txn/xa/forget+
Additional Required Headers::
+Accept: application/x-wf-jbmar-exception;version=1+
Additional Optional Headers::
+Cookie: JSESSIONID=\{sessionAffinityKey}+
Request Body::
JBoss marshalling representation of formatId, global ID and branch ID (the components of an XID).

==== Distributed Transaction Recovery

Method:: +GET+
URI:: +/txn/xa/recover+
Additional Required Headers::
+Accept: text/x-wf-txn-jbmar-xid-list;version=1,application/x-wf-jbmar-exception;version=1+
x-wf-txn-parent-name: The parent node name
x-wf-txn-recovery-flags: The recovery flags as a base 10 integer
Additional Optional Headers::
+Cookie: JSESSIONID=\{sessionAffinityKey}+
Request Body:: Empty

=== Transaction Responses

==== Begin Transaction

Message Type:: +application/x-wf-jbmar-new-txn;version=1+
Additional Required Headers::
+x-wf-txn-jbmar-id: \{transactionId}+
Additional Optional Headers::
+Set-Cookie: JSESSIONID=\{sessionAffinityKey}+
Response Body::
Jboss marshalling representation of formatId, global ID and branch ID (the components of an XID).
Response Codes::
 * +200+ Returned for a successful invocation

==== New Transaction

Message Type:: None
Additional Required Headers::
+x-wf-txn-jbmar-id: \{transactionId}+
Additional Optional Headers::
+Set-Cookie: JSESSIONID=\{sessionAffinityKey}+
Response Body:: Empty
Response Codes::
 * +202+ Returned for a successful invocation

==== Transaction Result

Message Type:: None
Addional Required Headers:: None
Additional Optional Headers::
x-wf-txn-jbmar-xa-read-only:true :: If this is present then the XA result was read only (only relevant for the prepare operation)
Response Body:: Empty
Response Codes::
 * +204+ Success
Notes::
This response is used to indicate operation success


==== Transaction XIDS

Message Type:: +text/x-wf-txn-jbmar-xid-list+
AdditionalRequiredHeaders:: None
Additional Optional Headers::
+Set-Cookie: JSESSIONID=\{sessionAffinityKey}+
Response Body::
Newline separated list of prepared but not submitted transactions
Response Codes::
 * +200+ Returned for a successful invocation
